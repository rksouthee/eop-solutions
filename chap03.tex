
\chapter{Associative Operations}


\begin{lemma}
	$a^na^m = a^ma^n = a^{n+m}$ (powers of the same element commute)
\end{lemma}

\begin{proof}
	Because all the groupings are equivalent we can move around the parenthesis and eventually remove
	the parentheses leaving us with $n + m$ elements.

	\begin{align*}
		a^na^m
		&= (\underbrace{aa \ldots aa}_{n \text{ times}})(\underbrace{aa \dots aa}_{m \text{ times}})\\
		&= (\underbrace{aa \ldots aa}_{m \text{ times}})(\underbrace{aa \dots aa}_{n \text{ times}})\\
		&= a^{m + n}\\
		&= a^{n + m}
	\end{align*}
\end{proof}

\begin{lemma}
	$(a^n)^m = a^{nm}$
\end{lemma}

\begin{proof}
	Because all the groupings are equivalent we can remove the parentheses and we end up with a total of
	$nm$ elements.

	\begin{align*}
		(a^n)^m
		&= \underbrace{(a^n)(a^n) \ldots (a^n)(a^n)}_{m \text{ times}}\\
		&= a^{nm}
	\end{align*}
\end{proof}

\begin{lemma}
	The binary operation of composition is associative.
\end{lemma}

\begin{proof}
	Let $f$, $g$, and $h$ be transformations on the same domain, we want to show
	\[ h \circ (g \circ f) = (h \circ g) \circ f. \]
	Using the definition of composition we have
	\begin{align*}
		h \circ (g \circ f)
		&= h \circ (g(f(x)))\\
		&= h(g(f(x)))
	\end{align*}
	and
	\begin{align*}
		(h \circ g) \circ f
		&= (h \circ g)(f(x))\\
		&= h(g(f(x))
	\end{align*}
\end{proof}

% TODO: should we add Theorem 3.1 for more context?
\begin{lemma}
	\verb|collision_point_nonterminating_orbit| can be used in the proof.
\end{lemma}

\begin{proof}
	Since $x$ is an element of finite order, there must be a cycle in which case the orbit
	does not terminate and we can use \verb|collision_point_nonterminating_orbit|.
\end{proof}

% TODO: should we include the code for power_3 for more context?
\begin{exercise}
	Convince yourself that the last three lines of code are correct
\end{exercise}

\begin{solution}
	After the loop we know that $n$ must be odd, and we can safely take the
	floor of $n$. If $n$ is now zero then $n$ must've been one, in which case it is the
	equivalent of $1a = a$ and we can return $a$. Finally we call \verb|power_accumulate_positive_0|,
	we can safely pass $a$ as the accumulator because we need to account for the floor division
	we performed earlier, and the \verb|op(a, a)| is also valid because of the division.
\end{solution}

\begin{exercise}
	Implement these procedures for C++ integral types.
\end{exercise}

\lstinputlisting[language=c++, firstline=32, lastline=114]{eop-code/integers.h}

\begin{project}
	Floating-point multiplication and addition are not associative, so they may give different
	results when they are used as the operation for \verb|power| and \verb|power_left_associated|;
	establish whether \verb|power| or \verb|power_left_associated| gives a more accurate result
	for raising a floating-point number to an integral power.
\end{project}

\begin{exercise}
	Rewrite all the algorithms in this chapter in terms of accumulation procedures.
\end{exercise}

\begin{project}
	Create a library for the generation of linear recurrence sequences based on the results
	of Miller and Brown [1966] and Fiduccia [1985].
\end{project}
