\chapter{Coordinates with Mutable Successors}

\begin{lemma}
	For each of the ranges $[h, t]$ returned by \verb|split_linked|, $h = l \Leftrightarrow t = l$.
\end{lemma}

\begin{exercise}
	Assuming that one of the ranges $(h, t)$ returned by \verb|split_linked| is not empty, explain what
	iterator $t$ points to and what the value of $\func{successor}(t)$ is.
\end{exercise}

\begin{solution}
	If one of the ranges $(h, t)$ is not empty, then $t$ points to the last iterator in the range $[f, l)$ such
	that $\forall i \in [successor(t), l) p(i) \neq p(t)$. For the successor we have either
	\[ \func{successor}(t) = l \vee p(t) \neq p(\func{successor}(t)). \]
\end{solution}

\begin{lemma}
	\verb|split_linked| is a precedence-preserving link rearrangement.
\end{lemma}

\begin{proof}
	\verb|split_linked| always links the tail to an iterator that succeeds itself once the corresponding
	head has been assigned.
\end{proof}

\begin{exercise}
	Implement \verb|combine_linked_nonempty|, allowing for empty inputs. What value should be returned as the
	last-visited iterator?
\end{exercise}

\lstinputlisting[language=c++, firstline=3264, lastline=3276]{eop-code/eop.h}

\begin{lemma}
	If a call $\func{combine\_linked\_nonempty}(f0, l0, l1, r, s)$ returns $(h, t, l)$, $h$ equals $f0$ or $f1$,
	and, independently, $l$ equals $l0$ or $l1$.
\end{lemma}

\begin{proof}
	At the start of the function, $h$ is either set to $f0$ or $f1$ and is not set again. The function
	has only two exit points and in one case $l$ equals $l0$ and in the other case $l$ equals $l1$.
\end{proof}

\begin{lemma}
	When state $s2$ is reached, $t$ is from the original range $[f0, l0)$, $\func{successor}(t) = l0$, and
	$f1 \neq l1$; when state $s3$ is reached, $t$ is from the original range $[f1, l1)$,
	$\func{successor}(t) = l1$, and $f0 \neq l0$.
\end{lemma}

\begin{proof}
	State $s2$ is only reached from state $s0$ when $f0 = l0$. There are three cases where we reach state
	$s0$. In two of the cases we call $\func{advance\_tail}(t, f0)$ before going to state $s0$ and in the other
	case we call $\func{link\_to\_tail}(t, f0$. In each case $t$ points to $f0$ and then $f0$ is advanced. Since
	we just assigned $t$ to $f0$ before advancing we have $\func{successor}(t) = l0$.
\end{proof}

\begin{lemma}
	\verb|combine_linked_nonempty| is a precedence-preserving link rearrangement.
\end{lemma}

\begin{proof}
	\verb|combine_linked_nonempty| always links the tail to an iterator that succeeds itself once the
	corresponding head has been assigned.
\end{proof}
