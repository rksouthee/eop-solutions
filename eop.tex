\documentclass{report}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{listings}

\theoremstyle{definition}
\newtheorem{lemma}{Lemma}[chapter]
\newtheorem{exercise}{Exercise}[chapter]
\newtheorem{project}{Project}[chapter]

\theoremstyle{remark}
\newtheorem*{solution}{Solution}

\lstset{
	language=c++,
	basicstyle=\ttfamily\normalsize,
	commentstyle=\itshape\rmfamily,
	columns=fullflexible,
	texcl=true}

\title{Elements of Programming Solutions}
\author{Robert Southee}
\date{}

\begin{document}

\maketitle

\chapter{Foundations}

\begin{lemma}
	If a value type is uniquely represented, equality implies
	representational equality.
\end{lemma}

\begin{proof}
	If two values are equal they represent the same abstract entity and
	since our value type is uniquely represented, each abstract entity
	has at most one representation, therefore comparing the
	representations of objects is sufficient for determining if two
	objects are equal.
\end{proof}

\begin{lemma}
	If a value type is not ambiguous, representational equality implies
	equality.
\end{lemma}

\begin{proof}
	If two values are representationally equal, then their datums are
	identical sequences of 0s and 1s, and since the value type is
	unambiguous they must represent the same abstract entity and therefore
	be equal.
\end{proof}

\begin{lemma}
	A well-formed object is partially formed.
\end{lemma}

\begin{proof}
	If we have a well-formed object, then once the scope of the object
	has expired the destructor will be called, therefore the destructor
	must be defined. Once we have the destructor we can view assignment
	as first destroying the object, then constructing the object with a new
	state.
\end{proof}

\begin{exercise}
	Extend the notion of regularity to input/output objects of a procedure,
	that is to objects that are modified as well as read.
\end{exercise}

\begin{solution}
	A procedure is regular with respect to input/output objects if
	replacing an input/output object with an equal object, then the two
	objects are equal after invocation.
\end{solution}

\begin{exercise}
	Assuming that \verb|int| is a $32$-bit two's complement type, determine
	the exact definition and result space.
\end{exercise}

\begin{solution}
	The definition space is the set of integers in the range $[46340,
	46340]$ and the result space is the set $\{ x^2 \mid x \in [0, 46340]
	\}$.
\end{solution}

\begin{project}
	Extend the notions of equality, assignment, and copy construction to
	objects of distinct types. Think about the interpretation of the two
	types and axioms that connect cross-type procedures.
\end{project}

\chapter{Transformations and Their Orbits}

\begin{lemma}
	\[ \mathtt{euclidean\_norm}(x, y, z) = \mathtt{euclidean\_norm}(\mathtt{euclidean\_norm}(x, y), z) \]
\end{lemma}

\begin{proof}
	\begin{align*}
		\mathtt{euclidean\_norm}(\mathtt{euclidean\_norm}(x, y), z)
		&= \sqrt{\left (\sqrt{x^2 + y^2} \right )^2 + z^2}\\
		&= \sqrt{x^2 + y^2 + z^2}\\
		&= \mathtt{euclidean\_norm}(x, y, z)
	\end{align*}
\end{proof}

\begin{exercise}
	Implement a definition-space predicate for addition on $32$-bit signed
	integers.
\end{exercise}

\lstinputlisting[firstline=3,lastline=8]{code/main.cpp}

\begin{lemma}
	An orbit does not contain both a cyclic and a terminal element.
\end{lemma}

\begin{proof}
	Let $x$ be cyclic under $f$, that is $x = f^n(x)$ for $n \geq 1$ and
	let $y$ be terminal under $f$. Since $x$ and $y$ belong to the same
	orbit, and $y$ is a terminal element, $y$ must be reachable from $x$.
	Since $y$ is reachable from $x$ we have $y = f^m(x)$ for $m \geq 0$.
	If $m < n$ then $x = f^{n - m}(y)$, but $n - m \geq 1$ and since $y$
	is terminal $f^{n - m}(y)$ is not defined. If $n = m$ then $x = y$,
	then we could substitute $y$ for $x$, that is $x = f^n(y)$, similarly
	since $n \geq 1$, $f(y)$ is not defined. Finally, if $m > n$, then
	$x = f^{m - n}(y)$ but $y$ is not in the definition space of $f$.
\end{proof}

\begin{lemma}
	An orbit contains at most one terminal element.
\end{lemma}

\begin{proof}
	Let us assume that an orbit contains more than one terminal element.
	For simplicity, let $x$ and $y$ be distinct elements terminal under
	$f$. Since $x$ and $y$ belong to the same orbit, they have a common
	element they're reachable from, let $z$ be such an element, then $x =
	f^n(z)$ and $y = f^m(z)$. Wihtout loss of generality, $n < m$, then $y
	= f^{m - n}(x)$ but since $m - n \geq 1$ and $x$ is terminal, then
	$f^{m - n}(x)$ is not defined.
\end{proof}

\begin{lemma}
	$o = h + c$
\end{lemma}

\begin{proof}
	Since we defined the orbit handle as the complement of the orbit cycle
	with respect to the cycle, then, $h = o - c$, therefore $o = h + c$.
\end{proof}

\begin{lemma}
	The distance from any point in an orbit to a point in a cycle of that
	orbit is always defined.
\end{lemma}

\begin{proof}
	For an element in an orbit, the distance to an element in the cycle
	is equal to the distance to the connection point plus the distance from
	the connection point to the element in the cycle.
\end{proof}

\begin{lemma}
	If $x$ and $y$ are distinct points in a cycle of size $c$,
	\[ c = \mathtt{distance}(x, y, f) + \mathtt{distance}(y, x, f) \]
\end{lemma}

\begin{lemma}
	If $x$ and $y$ are points in a cycle of size $c$, the distance from $x$
	to $y$ satisfies
	\[ 0 \leq \mathtt{distance}(x, y, f) < c \]
\end{lemma}

\begin{lemma}
	If the orbits of two elements intersect, they have the same cyclic
	elements.
\end{lemma}

\begin{exercise}
	Design an algorithm that determines, given a transformation and its
	definition-space predicate, whether the orbits of two elements
	intersect.
\end{exercise}

\begin{exercise}
	The precondition of \verb|convergent_point| ensures termination.
	Implement an algorithm \verb|convergent_point_guarded| for use when
	that precondition is not known to hold, but there is an element in
	common to the orbits of both $x0$ and $x1$.
\end{exercise}

\begin{exercise}
	Derive formulas for the count of different operations ($f$, $p$,
	equality) for the algorithms in this chapter.
\end{exercise}

\begin{exercise}
	Use \verb|orbit_structure_nonterminating| to determine the average
	handle size and cycle size of the pseudorandom number generators on
	your platform for various seeds.
\end{exercise}

\begin{exercise}
	Rewrite all the algorithms in this chapter in terms of actions.
\end{exercise}

\begin{project}
	Another way to detect a cycle is to repeatedly test a single
	advancing element for equality with a stored element while replacing
	the stored element at ever-increasing intervals. This and other ideas
	are described in Sedgewick, et al. [1979], Brent [1980], and Levy
	[1982]. Implement other algorithms for orbit analysis, compare their
	performance for different applications, and develop a set of
	recommendations for selecting the appropriate algorithm.
\end{project}

\end{document}
